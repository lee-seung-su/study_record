업캐스팅, 다운캐스팅은 다형성에서 나오는개념이다
부모, 자식클래스는 서로 형변환이 가능한데
자식클래스 -> 부모클래스 : 업캐스팅
부모클래스 -> 자식클래스 : 다운캐스팅이라한다(주로 업캐스팅한거를 다시 돌리는거를 다운캐스팅)
다운캐스팅하면 본질은 부모클래스이므로 자식클래스만에 있는 메소드 쓸 수 없다. !!! 중요 !!!
업캐스팅하고나서 원본 객체가 뭐였는지 확인하기위해 instance of 을 쓰기도한다.
업캐스팅은 컴파일러가 자동적으로 해준다
Parent p = new Child() 에서 Parent p를 참조변수, new Child()를 새로운 인스턴스 이렇게 표현한다

다형성의 장점은 한가지 타입으로 여거 객체 선언가능?
People p = new BodyBuilder();
People p = new Soccerplayer();
People p = new Basketballplayer(); 뭐 이런느낌? + BodyBuilder, Soccerplayer, Basketballplayer모두
각자 받는 타입이 정해져있으므로 p= Soccerplayer 했을떄 자동적으로 앞으로 p가 받는 인자는
soccerplayer와 관련된것임이 확인된다.  즉 타입검사가 필요없다.

https://madplay.github.io/post/java-upcasting-and-downcasting

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
java는 무조건 call by value이다.
call by value - 값 복제해서 사용
cal by reference - 주소값 전달

자바에는 int, float, double, char등의 기본자료형과
Array, List, String 그리고 기본자료형을 wrapping해주는 Wrapper클래스인 Integer, Float 등의 참조자료형(객체)이 있다.
따라서 기본자료형을 함수에 인자로 전달하는 경우에는 당연히 call by value로 값이 전달
참조 자료형을 전달하는 경우에도 마찬가지로 call by value이지만 이때는 주소가 전달된다.
하지만 주소를 이용해서 접근한다해서 해당 객체의 값을 무조건 바꿀수 있는게 아니고 setter라는 메서드가 있을떄만
변경이 가능하다.
따라서 Wrapper클래스와 String은 immutable class이므로 값을 변경할 수 없다.
그  외의 Array, List는 mutable이기떄문에 arr[3] = arr[4]; 이런식이나 arr.set() 이렇게 값 변경가능

즉 java는 무조건 call by value이고, String, Integer등은 immutable이므로 변경불가능한것
그래서 주로 immutable인 String class보다 mutable인 StringBuilder class를 쓴다
사용법은 거의 비슷

참고로 setter가 있는 커스텀객체는 값 변경가능!!

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
메모리구조는 다음과 같다(낮은주소부터 높은주소 순으로)

코드 : 실행할 프로그램의 코드
데이터 : 전역, 정적(static)변수
힙 : 힙 변수(주로 동적할당 변수) -> free안해주면 메모리 누수발생
스택 : 지역변수

static변수란 정적변수로 메모리에 한번만 로드되는 변수를 의미한다
따라서 해당 변수가 선언되어있는 파일에서는 공유가 가능하다
주로 쓰레드처럼 공유자원이 있고 나머지는 개인영역이 있는것처럼 공유자원이 있을 떄 공유변수를 static으로 둔다
java에서 main이 static이라는거는 여러 .class파일이 있어도 main은 공유한다는 의미로 보면됨

이떄 이 static에 final키워드까지 붙인다면 상수가된다. (final - 변경불가)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
자바에서 interface를 구현하려고하면 lambda라는 익명함수를 사용할 수 있다.
public interface test{
    public int func(int a);
} 이렇게 돼있으면

test t1 = (a) -> {System.out.println("print"); return a} 이렇게 사용한다
이떄 인터페이스에 함수 여러개있으면 어떤 함수쓰는지 모르니깐 이때 생성할 참조인터페이스는 반드시
인터페이스함수가 1개여야한다

java.util.functionality인가? 여기에도 이미 만들어진 interface api있다.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
코드를 작성하고 이걸 컴파일(컴파일러 + 어셈블러)거친후에 나오는 코드가 바이너리 코드다.
어셈블리어랑 바이너리코드랑은 1대1 매칭되어있고
어셈블리어는 사용자 편하게, 바이너리코드는 컴퓨터 편하게 되어있는 코드이다.
바이너리코드는 os? cpu마다 다르게 매칭되어있다..
즉 컴퓨터는 바이너리코드보고 코드를 이해
but java는 java compiler로 컴파일하면 .class파일이나온다
.class파일은 바이트코드라하며 jvm이라는 java 가상머신에서 이해할수있는 코드다
이 바이트코드를 가상머신에서 해당되는 언어로 다시 컴파일(JIT가 해준다)해주는 방식으로 자바는 컴파일된다
따라서 자바는 다른 바이너리코드에 비해 호환성이 좋지만 느리다.(2번 컴파일)
