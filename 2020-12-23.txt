html이란
한 페이지에서 다른 페이지로 넘어갈 수 있는 마크업 언어
마크업 언어란 문서의 내용 뿐만아니라 출력형식, 배치 등의 추가정보를 마크업이라고한다
즉 .html이라는 확장자를 가진문서를 사용자가 참고하고싶으면 웹브라우저로 요청을 보낸다
웹브라우저는 서버로 요청을 전송하고 그 과정에서 웹브라우저가 이해하기 쉬운구조인 DOM트리 형태로 만든다음
CSS라는 파일역시(여러 페이지에 공통으로 적용하겠다라는 파일) CSSOM으로 만든뒤 두 트리를 가지고 렌더링트리를 만든다
이를 반환해주면 브라우저에 있는 렌더링엔진으로 이를 브라우저에 뿌려주고 사용자가 view를 통해 이를 보는 방식으로 동작

특징 : 여러 태그들을 가지며 이러한 태그들을 사용하여 원하는 형태의 문서 생성가능
웹페이지란 : 웹상에 존재하는 모든 문서
웹이란 : 인터넷에 연결된 여러컴퓨터를 통해 사람들간 정보를 공유할 수 있는 세계적 정보공간을 의미
브라우저란 웹페이지, 비디오, 이미지등을 표현하는 sw로 서버~클라이언트 모델이다
///////////////////////////////////////////////////////////////////////////////
gcc/g++할떄 라이브러리 추가하고싶으면 -l옵션 쓰면된다
우선 .h와 .c로 구성된 파일들로 컴파일하여 목적파일(.o)생성 gcc -c aa aa.h aa.c 뭐 이런식으로
그다음에 정적라이브러리를 만드는 명령어인 ar rc를 통해 정적라이브러리 생성(앞에다가  lib~이런식으로 붙여줘야함 / 확장자는 주로 .a)
이름이 libaa.a라면 나중에 해당  .h파일을 main에다가 추가만 해주고 컴파일 시 파일이름의 lib를 뺸 aa가 라이브러리 이름이 된다.

만약 만든 라이브러리가 표준뭐시기에 등록되어있으면 -laa해도되는데 아니라면 -L./ -laa이런식으로 위치를 지정해주면 된다
주로 /lib, /usr/lib, /usr/local/lib만 검색해서 여기다가 등록하면 -l쓸수있나?

////////////////////////////////////////////////////////////////////////
커널이란 시스템상에 존재하는 cpu, 메모리, 프로세스, 파일시스템 등의 자원을 효율적으로 관리해주는 자원관리자이다. 운영체제의 핵심
/////////////////////////////////////////////////////////////////////////////////

elf파일은 -o나 .exe파일만 elf파일이라한다. 뭐 자세한 공유가능한 오브젝트파일 뭐시기 있는데 생략
elf파일은 elf헤더, program table / section table로 구성
readelf -I하면 elf헤더만
readelf -I하면 program table / -l인가 가물가물
readelf -S하면 section table
elf헤더는 그냥 전체elf파일에 대한 간략한 설명. 전체 elf파일에서 offset0에 위치
program table은 .bss(초기화되지않은 변수위치) / .rodata(read only data위치) / .data(초기화된 전역변수위치) / .txt(elf파일에서 실행가능한 코드가 opcode(기계어)로 변환되어있는 위치)
이런것들의 위치를 알려주는 부분
section table은 전체코드에서 어느부분이 program table의 특정영역으로 해당되는지 등을 알려주는것같다.
즉 elf파일은 해당파일이 메모리로 로드될떄 해당부분의 어느영역은 메모리상의 이동될 offset을 알려주는것같다.(? 잘모름)
//////////////////////////////////////////////////////////////////////////////
소켓통신
server : 소켓생성 -> bind(서버의 ip와 포트를 연결해주는 링크작업이라 이해하면됨/ client에서 ip만 알아도 포트알 수 있도록)->
-> listen(대기상태들어감) -> client요청이 들어오면 accept -> client소켓이랑 통신 -> close
client : 소켓생성 -> connect요청 -> server소켓이랑 통신 -> close
pthread쓸때 pthread변수 만들고, pthread_create로 함수랑 연결하고, pthread_join으로 실행.

채팅프로그램만들떄 read, write부분을 pthread로 구현 + mutex로 각 작업 lock해줘야 읽고쓰는 채팅프로그램 구현가능